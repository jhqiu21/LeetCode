{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetCode Notes","text":"<p>This is Notes of LeetCode Question which I have tried and found it interesting! And I will also summarize the important methodology based on the questions I tried before.</p> <p>The questions I did are mostly based on this list. And I also refer to Grind 75 to make plans!</p>"},{"location":"Style%20Guide/","title":"Style Guide","text":"<p>Following this awesome Java Style Guide</p>"},{"location":"1%2B/1.%20Two%20Sum/","title":"1. Two Sum","text":"<p>\ud83d\udd17 Source</p>"},{"location":"1%2B/1.%20Two%20Sum/#intuition","title":"Intuition","text":""},{"location":"1%2B/1.%20Two%20Sum/#approach","title":"Approach","text":""},{"location":"1%2B/1.%20Two%20Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: $$</li> <li>Space complexity: $$</li> </ul>"},{"location":"1%2B/1.%20Two%20Sum/#code","title":"Code","text":"<pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int high = nums.length;\n        HashMap&lt;Integer, Integer&gt; h = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; high; i++) {\n            int val = target - nums[i];\n            if (h.containsKey(val)) {\n                return new int[]{i, h.get(val)};\n            }\n            h.put(nums[i], i);\n        }\n        return new int[2];\n    }\n}\n</code></pre>"},{"location":"1%2B/11.%20Container%20With%20Most%20Water/","title":"11. Container With Most Water","text":"<p>\ud83d\udd17 Source:</p>"},{"location":"1%2B/11.%20Container%20With%20Most%20Water/#intuition","title":"Intuition","text":"<p>Give a list of number, find maximum volumn between two entries given that  $$ \\text{Volumn} = \\min(\\text{nums}[i],\\text{nums}[j]) \\times (j - i) $$ for \\(0 \\le i &lt; j &lt; \\text{len}\\)</p>"},{"location":"1%2B/11.%20Container%20With%20Most%20Water/#approach","title":"Approach","text":"<p>Use Sliding Windows approach.</p> <ul> <li>Step 1:<ul> <li>creat two pointer <code>low</code> and <code>high</code> pointing to the start and end position of the given array.</li> <li>creat variable <code>max</code> to store the max value we ever get and keep updating max during loop iteration.</li> </ul> </li> <li>Step 2: During loop iteration, <ul> <li>If <code>height[low] &lt; height[high]</code>, move <code>low</code> pointer until current height is less than or equal to <code>height[low]</code>.</li> <li>If <code>height[low] &gt;= height[high]</code>, move <code>high</code> pointer until current height is less than or equal to <code>height[height]</code>.</li> </ul> </li> <li>Hence, in every loop, we will get a higher height than the previous one. The loop iteration ends when two pointer encounters. Finally, we return the maximum value of volumn we get during iteration.</li> </ul>"},{"location":"1%2B/11.%20Container%20With%20Most%20Water/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1%2B/11.%20Container%20With%20Most%20Water/#code","title":"Code","text":"<pre><code>class Solution {\n    public int maxArea(int[] height) {\n        int low = 0;\n        int high = height.length - 1;\n        int volumn = 0;\n        int h = 0;\n        while (low &lt; high) {\n            h = Math.min(height[low], height[high]);\n            volumn = Math.max(h * (high - low), volumn);\n            if (height[low] &lt; height[high]) {\n                low++;\n                while(low &lt; high &amp;&amp; h &gt; height[low]) { \n                    low++;\n                }\n                h = height[low];\n            } else {\n                high--;\n                while(low &lt; high &amp;&amp; h &gt; height[high]) { \n                    high--;\n                }\n                h = height[high];\n            }\n        }\n        return volumn;\n    }\n}\n</code></pre>"},{"location":"1%2B/15.%203Sum/","title":"15. 3Sum","text":"<p>\ud83d\udd17 Source</p>"},{"location":"1%2B/15.%203Sum/#intuition","title":"Intuition","text":"<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p> <p>Naive Solution: Traverse the given array \\(O(n^3)\\) times.</p>"},{"location":"1%2B/15.%203Sum/#approach","title":"Approach","text":"<ul> <li>Step 1: Sort the array so that we can use sliding window approach. (Sorting the array takes \\(O(N\\log N)\\) times)</li> <li>Step 2: Creat a hash map <code>list</code> and add all elements.</li> <li>Step 3: For each element in the hash map, apply Two Sum approach!<ul> <li>Outer Loop: Selects the first element <code>nums[i]</code> and ensures it is not greater than <code>0</code>.</li> <li>Inner Loop: Selects the second element <code>nums[j]</code> and calculates the required third element as <code>target = 0 - nums[i] - nums[j]</code>.</li> <li>Hash Map Lookup: Uses the hash map to check if the third element exists and its index is greater than <code>j</code> to ensure the triplet is unique.</li> <li>Update Loop Variables: Uses the hash map to update <code>j</code> and <code>i</code> to skip over duplicate elements.</li> </ul> </li> </ul>"},{"location":"1%2B/15.%203Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(T(N) = O(N^2 + N\\log N) = O(N^2)\\)</li> <li>Space complexity: \\(O(N)\\) as we implement a hash map. To optimize, we can use two pointer approach.</li> </ul>"},{"location":"1%2B/15.%203Sum/#code","title":"Code","text":"<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        if (nums.length &lt; 3 || nums[0] &gt; 0) {\n            return res;\n        }\n\n        HashMap&lt;Integer, Integer&gt; list = new HashMap&lt;&gt;();\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            list.put(nums[i], i);\n        }\n\n        for (int i = 0; i &lt; nums.length - 2; i++) {\n            if (nums[i] &gt; 0) {\n                break;\n            }\n            for (int j = i + 1; j &lt; nums.length - 1; j++) {\n                int target = 0 - nums[i] - nums[j];\n                if (list.containsKey(target) &amp;&amp; list.get(target) &gt; j) {\n                    res.add(Arrays.asList(nums[i], nums[j], target));\n                }\n                j = list.get(nums[j]);\n            }\n            i = list.get(nums[i]);\n        }\n        return res;\n    }\n}\n</code></pre>"},{"location":"1%2B/19.%20Remove%20Nth%20Node%20From%20End%20of%20List/","title":"19. Remove Nth Node From End of List","text":"<p>Source: https://leetcode.com/problems/remove-nth-node-from-end-of-list/</p>"},{"location":"1%2B/19.%20Remove%20Nth%20Node%20From%20End%20of%20List/#intuition","title":"Intuition","text":"<p>Naive Solution: Use \\(len - n\\) pass recursion.</p> <ul> <li>Get the length of the linked list</li> <li>calculate the removal position</li> <li>Use recursion version of removal function</li> </ul> <pre><code>class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int key = length(head) - n + 1;\n        return removeNthFromStart(head, key);\n    }\n\n    private int length(ListNode head) {\n        int size = 0;\n        while (head != null) {\n            size++;\n            head = head.next;\n        }\n        return size;\n    }\n\n    private ListNode removeNthFromStart(ListNode head, int n) {\n        if (n == 1) {\n            return head.next;\n        }\n        return new ListNode(head.val, removeNthFromStart(head.next, n - 1));\n    }\n}\n</code></pre>"},{"location":"1%2B/19.%20Remove%20Nth%20Node%20From%20End%20of%20List/#approach","title":"Approach","text":"<ul> <li>Calculate the length of linked list</li> <li>Traverse the linked list using loop, when arrive the removal position, simply jump to the next node.</li> <li>Get removed linked list.</li> </ul>"},{"location":"1%2B/19.%20Remove%20Nth%20Node%20From%20End%20of%20List/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1%2B/19.%20Remove%20Nth%20Node%20From%20End%20of%20List/#code","title":"Code","text":"<pre><code>class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode memo = null;\n        int size = 0;\n        int count = 0;\n        while (head != null) {\n            size++;\n            memo = new ListNode(head.val, memo);\n            head = head.next;\n        }\n        while (size &gt; 0) {\n            count++;\n            if (count == n) {\n                memo = memo.next;\n                size--;\n                continue;\n            }\n            head = new ListNode(memo.val, head);\n            memo = memo.next;\n            size--;\n        }\n        return head;\n    }\n}\n</code></pre>"},{"location":"1%2B/3.%20Longest%20Substring%20Without%20Repeating%20Characters/","title":"3. Longest Substring Without Repeating Characters","text":"<p>Source: https://leetcode.com/problems/longest-substring-without-repeating-characters/description/</p>"},{"location":"1%2B/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#intuition","title":"Intuition","text":"<p>Using hash set to track each character in the string. And set two pointers <code>low</code> and <code>high</code> to traverse the hold string. </p> <ul> <li>When the hashset contains the same character with that at high pointer, keep moving <code>low</code> pointer right until    the set has no duplicate characters</li> <li>If current hashset do not has charachter at <code>high</code> pointer, add current character and move the <code>high</code> pointer right </li> </ul> <p>During the traverse process, use <code>max</code> to store the maximum length of substring.</p> <pre><code>class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int low = 0;\n        int high = 0;\n        int max = 0;\n        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();\n\n        while(high &lt; s.length()) {\n            if (set.contains(s.charAt(high))) {\n                set.remove(s.charAt(low));\n                low++;\n            } else {\n                set.add(s.charAt(high));\n                high++;\n            }\n            max = Math.max(max, high - low);\n        }\n        return max;\n    }\n}\n</code></pre>"},{"location":"1%2B/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#approach-optimal","title":"Approach (Optimal)","text":"<p>Note that <code>s</code> consists of English letters, digits, symbols and spaces, we initialize an array of size 128 to  store the least position of each character in <code>s</code>.  If this is duplication in a character <code>c</code>, we move the <code>low</code> pointer to \"next position\" store in the array to reduce the unnecessary comparsion.</p>"},{"location":"1%2B/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1%2B/3.%20Longest%20Substring%20Without%20Repeating%20Characters/#code","title":"Code","text":"<pre><code>class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int max = 0;\n        int[] arr = new int[128];\n        int low = 0;\n        int high = 0;\n        while (high &lt; s.length()) {\n            low = Math.max(low, arr[s.charAt(high)]);\n            max = Math.max(max, high - low + 1);\n            // Store the 'next position' for low pointer to 'jump'\n            arr[s.charAt(high)] = high + 1;\n            high++;\n        }\n        return max;\n    }\n}\n</code></pre>"},{"location":"1%2B/33.%20Search%20in%20Rotated%20Sorted%20Array/","title":"33. Search in Rotated Sorted Array","text":"<p>Source: https://leetcode.com/problems/search-in-rotated-sorted-array/description/</p>"},{"location":"1%2B/33.%20Search%20in%20Rotated%20Sorted%20Array/#approach","title":"Approach","text":"<p>Search in the rotated sorted array, we need to decide our search range, like binary search.  We first define reverse point be the entry where </p> \\[a[i - 1] &gt; a[i] \\text{ and } a[i + 1] &gt; a[i]\\] <ul> <li> <p>If <code>nums[low] &lt;= nums[mid]</code></p> </li> <li> <p>If <code>nums[low] &gt; nums[mid]</code>, the reverse point lie in the range.</p> </li> </ul>"},{"location":"1%2B/33.%20Search%20in%20Rotated%20Sorted%20Array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(\\log n)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1%2B/33.%20Search%20in%20Rotated%20Sorted%20Array/#code","title":"Code","text":"<pre><code>class Solution {\n    public int search(int[] nums, int target) {\n        if (nums.length == 1) {\n            return nums[0] == target ? 0 : -1;\n        }\n\n        int low = 0; \n        int high = nums.length - 1;\n        while (low &lt;= high) {\n            int mid = (low + high) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            if (nums[low] &lt;= nums[mid]) {\n                if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            // mid = (low + high) / 2;\n        }\n        return -1;\n    }\n}\n</code></pre>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/","title":"42. Trapping Rain Water","text":"<p>\ud83d\udd17 Source</p>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#intuition","title":"Intuition","text":"<p>For this question, we should note that the height of water in <code>height[i]</code> is determined by the minimum of its \"left maximum\" and \"right maximum\"</p> <p><code>res[i] = Math.max(lmax[i], rmax[i]) - height[i]</code></p>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#solution-1","title":"Solution 1","text":"<p>Use array <code>lmax</code> and <code>rmax</code> to store the \"left maximum\" and \"right maximum\" for each index and iterate the <code>height</code> array to get the total volumn.</p>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(N)\\)</li> <li>Space complexity: \\(O(N)\\)</li> </ul>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#code","title":"Code","text":"<pre><code>class Solution {\n    public int trap(int[] height) {\n        int len = height.length;\n        int[] lmax = new int[len];\n        int[] rmax = new int[len];\n        int total = 0;\n\n        lmax[0] = height[0];\n        for (int i = 1; i &lt; len; i++) {\n            lmax[i] = Math.max(lmax[i-1], height[i]);\n        }\n\n        rmax[len - 1] = height[len - 1];\n        for (int i = len - 2; i &gt;= 0; i--) {\n            rmax[i] = Math.max(rmax[i+1], height[i]);\n        }\n\n        for (int i = 0; i &lt; len; i++) {\n            total += Math.min(lmax[i], rmax[i]) - height[i];\n        }\n\n        return total;\n    }\n}\n</code></pre>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#solution-2","title":"Solution 2","text":"<p>Use two pointers to store the left maximum and right maximum. This approach optimize the space complexity.</p> <ul> <li><code>lmax</code> &lt; <code>rmax</code>:  we can learn that on the \"left part\", the height of water must be determined by <code>lmax</code></li> <li> <p>Similarly, if <code>lmax</code> &gt;= <code>rmax</code>, we can conclude that on the \"right part\", the height of water must be determined by <code>rmax</code></p> <p></p> </li> </ul>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#complexity_1","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(N)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#code_1","title":"Code","text":"<pre><code>class Solution {\n    public int trap(int[] height) {\n        int l = 0;\n        int r = height.length - 1;\n        int lmax = 0;\n        int rmax = 0;\n        int total = 0;\n\n        while (l &lt; r) {\n            lmax = Math.max(lmax, height[l]);\n            rmax = Math.max(rmax, height[r]);\n\n            if (lmax &lt; rmax) {\n                total += lmax - height[l];\n                l++;\n            } else {\n                total += rmax - height[r];\n                r--;\n            }\n        }\n        return total;\n    }\n}\n</code></pre>"},{"location":"1%2B/42.%20Trapping%20Rain%20Water/#similar-question","title":"Similar Question","text":"<ul> <li>Trapping Rain Water II</li> </ul>"},{"location":"1%2B/53.%20Maximum%20Subarray/","title":"53. Maximum Subarray","text":"<p>Source: https://leetcode.com/problems/maximum-subarray/description/</p>"},{"location":"1%2B/53.%20Maximum%20Subarray/#intuition","title":"Intuition","text":""},{"location":"1%2B/53.%20Maximum%20Subarray/#approach","title":"Approach","text":""},{"location":"1%2B/53.%20Maximum%20Subarray/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"1%2B/53.%20Maximum%20Subarray/#code","title":"Code","text":"<pre><code>class Solution {\n    public int maxSubArray(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int max = nums[0];\n        res[0] = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            if (res[i - 1] &lt; 0) {\n                res[i] = nums[i];\n            } else {\n                res[i] = res[i - 1] + nums[i];\n            }\n            max = Math.max(max, res[i]);\n        }\n        return max;\n    }\n}\n</code></pre>"},{"location":"1%2B/67.%20Add%20Binary/","title":"67. Add Binary","text":""},{"location":"1%2B/70.%20Climbing%20Stairs/","title":"70. Climbing Stairs","text":"<p>Source: https://leetcode.com/problems/climbing-stairs/description/</p>"},{"location":"1%2B/84.%20Largest%20Rectangle%20in%20Histogram/","title":"84. Largest Rectangle in Histogram","text":"<p>Source: https://leetcode.com/problems/largest-rectangle-in-histogram/description/</p>"},{"location":"1%2B/84.%20Largest%20Rectangle%20in%20Histogram/#intuition","title":"Intuition","text":""},{"location":"1%2B/84.%20Largest%20Rectangle%20in%20Histogram/#approach","title":"Approach","text":""},{"location":"1%2B/84.%20Largest%20Rectangle%20in%20Histogram/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"1%2B/84.%20Largest%20Rectangle%20in%20Histogram/#code","title":"Code","text":""},{"location":"100%2B/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<p>\ud83d\udd17 Source</p>"},{"location":"100%2B/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/#intuition","title":"Intuition","text":""},{"location":"100%2B/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/#approach","title":"Approach","text":""},{"location":"100%2B/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(n)\\)</li> </ul>"},{"location":"100%2B/105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        int end = preorder.length - 1;\n        for (int i = 0; i &lt; inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n        return build(preorder, 0, end, inorder, 0, end, map);\n    }\n\n    private TreeNode build(int[] preorder, int preStart, int preEnd, \n                           int[]inorder, int inStart, int inEnd, \n                           Map&lt;Integer,Integer&gt; map) {\n        if (preStart &gt; preEnd || inStart &gt; inEnd) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[preStart]);\n        int inRoot = map.get(root.val);\n        int numsLeft = inRoot - inStart;\n        root.left = build(preorder, preStart + 1, preStart + numsLeft, \n                          inorder, inStart, inRoot - 1, map);\n        root.right = build(preorder, preStart + numsLeft + 1, preEnd, \n                           inorder, inRoot + 1, inEnd, map);\n        return root;\n    }\n\n}\n</code></pre>"},{"location":"100%2B/152.%20Maximum%20Product%20Subarray/","title":"152. Maximum Product Subarray","text":"<p>Source https://leetcode.com/problems/maximum-product-subarray/description/</p>"},{"location":"100%2B/152.%20Maximum%20Product%20Subarray/#intuition","title":"Intuition","text":""},{"location":"100%2B/152.%20Maximum%20Product%20Subarray/#approach","title":"Approach","text":""},{"location":"100%2B/152.%20Maximum%20Product%20Subarray/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"100%2B/152.%20Maximum%20Product%20Subarray/#code","title":"Code","text":""},{"location":"100%2B/169.%20Majority%20Element/","title":"169. Majority Element","text":"<p>\ud83d\udd17 Source</p>"},{"location":"100%2B/169.%20Majority%20Element/#intuition","title":"Intuition","text":"<p>Given an list of numbers of size <code>n</code>, return the element that appears more than <code>\u230an / 2\u230b</code> times. </p> <ul> <li>You may assume that the majority element always exists in the array.</li> <li>There is only one majority element in the given array.</li> <li>An array of Integer</li> <li><code>n == nums.length</code></li> <li><code>1 &lt;= n &lt;= 5 * 10^4</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> </ul>"},{"location":"100%2B/169.%20Majority%20Element/#solution-1-hashmap","title":"Solution 1 HashMap","text":""},{"location":"100%2B/169.%20Majority%20Element/#approach","title":"Approach","text":"<ul> <li>Step 1: Create a hash map <code>res</code> to store the stats of elements in the given array </li> <li>Step 2: During the loop iteration, for <code>nums[i]</code><ul> <li>If <code>res</code> does not contain a key <code>nums[i]</code>, add it and set its value as the number of appearance, initializing as 1.</li> <li>If <code>res</code> contains a key <code>nums[i]</code>, update its number of appearance.</li> </ul> </li> <li>Step 3: When we encounter a key whose value is greater than <code>\u230an / 2\u230b</code>, return this key.</li> </ul>"},{"location":"100%2B/169.%20Majority%20Element/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(k)\\) for k distinct element in array</li> </ul>"},{"location":"100%2B/169.%20Majority%20Element/#code","title":"Code","text":"<pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        int n = nums.length;\n        for (int i = 0; i &lt; nums.length; i++) {\n            int before = map.getOrDefault(nums[i], 0);\n            if (before == n / 2) {\n                return nums[i];\n            }\n            map.put(nums[i], before + 1);\n        }\n        return -1;\n    }\n}\n</code></pre>"},{"location":"100%2B/169.%20Majority%20Element/#solution-2-vote","title":"Solution 2 \"Vote\"","text":""},{"location":"100%2B/169.%20Majority%20Element/#approach_1","title":"Approach","text":"<p>There is a \"clever\" approach to solve this problem, </p> <ul> <li>Firstly, we set <code>nums[0]</code> as candidate <code>res</code>, and initialize the candidate's vote <code>count</code> to 1.</li> <li>When we encounter the same number as <code>res</code> is , the vote <code>count++</code>, otherwise the vote <code>count--</code>.</li> <li>When the vote <code>count</code> is 0, change the candidate and reset the vote <code>count</code> to 1.</li> <li>After traversing the array, our candidate number <code>res</code> is the final answer.</li> </ul> <p>Why? This is equivalent to each \u2018majority element\u2019 canceling out with other elements in pairs. By the end, there will definitely be at least one \u2018majority element\u2019 remaining.</p> <p>For this solution, as we simply traverse the array without implementing any other extra data structure, we optimize the space complexity!</p> <p>Reference: \ud83d\udd17 Boyer-Moore Majority Vote Algorithm</p>"},{"location":"100%2B/169.%20Majority%20Element/#complexity_1","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"100%2B/169.%20Majority%20Element/#code_1","title":"Code","text":"<pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        int res = 0;\n        for (int num : nums) {\n            if (count == 0) {\n                res = num;\n            }\n            if (num == res) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return res;\n    }\n}\n</code></pre>"},{"location":"100%2B/200.%20Number%20of%20Islands/","title":"200. Number of Islands","text":"<p>Source: https://leetcode.com/problems/number-of-islands/description/</p>"},{"location":"100%2B/200.%20Number%20of%20Islands/#intuition","title":"Intuition","text":"<p>Traverse the grid array using DFS. Check every entry in the array and use <code>count</code> to store the number of island.</p>"},{"location":"100%2B/200.%20Number%20of%20Islands/#approach","title":"Approach","text":"<p>When we visit a cell in the grid, we set its value as <code>'0'</code>, as when we encounter the cell with '0', we simply ignore it and visit next cell. The invalid case for DFS is </p> <ul> <li><code>row &lt; 0 || row &gt;= grid.length</code></li> <li><code>col &lt; 0 || col &gt;= grid[0].length</code></li> <li><code>grid[row][col] != '1'</code></li> </ul>"},{"location":"100%2B/200.%20Number%20of%20Islands/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(R \\times C)\\), in the worst case, we need to visit every cell in the grid.</li> </ul> <ul> <li>Space complexity: \\(O(R \\times C)\\), in the worst case, all cells in the grid are land cells, thus DFS will be called \\(R\\times C\\) times</li> </ul>"},{"location":"100%2B/200.%20Number%20of%20Islands/#code","title":"Code","text":"<pre><code>class Solution {\n    public int numIslands(char[][] grid) {\n        int row = grid.length;\n        int col = grid[0].length;\n        boolean isCheck[][] = new boolean[row][col];\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n        int count = 0;\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = 0; j &lt; col; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private void dfs(char[][] grid, int row, int col) {\n        if (row &lt; 0 || row &gt;= grid.length || \n            col &lt; 0 || col &gt;= grid[0].length || \n            grid[row][col] != '1') {\n            return ;\n        }\n        grid[row][col] = '0';\n        dfs(grid, row + 1, col);\n        dfs(grid, row, col + 1);\n        dfs(grid, row - 1, col);\n        dfs(grid, row, col - 1);\n    }\n}\n</code></pre>"},{"location":"1000%2B/1448.%20Count%20Good%20Nodes%20in%20Binary%20Tree/","title":"1448. Count Good Nodes in Binary Tree","text":"<p>\ud83d\udd17 Source</p>"},{"location":"1000%2B/1448.%20Count%20Good%20Nodes%20in%20Binary%20Tree/#approach","title":"Approach","text":"<p>Recursion, using variable <code>max</code> to log the previous maximum value and compare <code>max</code> with current root value.</p>"},{"location":"1000%2B/1448.%20Count%20Good%20Nodes%20in%20Binary%20Tree/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(N)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"1000%2B/1448.%20Count%20Good%20Nodes%20in%20Binary%20Tree/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int goodNodes(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int max= root.val;\n        return 1 + helper(root.left, max) + helper(root.right, max);\n    }\n\n    public int helper(TreeNode root, int max) {\n        if (root == null) {\n            return 0;\n        }\n        if (max &gt; root.val) {\n            return helper(root.left, max) + helper(root.right, max);\n        }\n        max = Math.max(max, root.val);\n        return 1 + helper(root.left, max) + helper(root.right, max);\n    }\n}\n</code></pre>"},{"location":"200%2B/207.%20Course%20Schedule/","title":"207. Course Schedule","text":"<p>\ud83d\udd17 Source</p>"},{"location":"200%2B/207.%20Course%20Schedule/#intuition","title":"Intuition","text":"<p>We traverse the graph and find if there is a topological </p>"},{"location":"200%2B/207.%20Course%20Schedule/#approach","title":"Approach","text":"<ul> <li>Create a 1-d array <code>visit</code> to record the visit status, with 3 states:<ul> <li>0 means it has not been visited</li> <li>1 means it has been visited</li> <li>-1 means there is a conflict</li> </ul> </li> <li>Firstly, build a directed graph, and then start from the first course, find which course it can constitute, temporarily mark the current course as visited</li> <li>Call DFS recursion on the newly obtained course until a new course has been visited, then return false, if there is no conflict, return true, and then change the course marked as visited to unvisited.</li> </ul>"},{"location":"200%2B/207.%20Course%20Schedule/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(V+E)\\)</li> <li>Space complexity: \\(O(V)\\)</li> </ul>"},{"location":"200%2B/207.%20Course%20Schedule/#code","title":"Code","text":"<pre><code>class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List&lt;Integer&gt;[] adjcent = new List[numCourses];\n        int[] visit = new int[numCourses];\n        for (int i = 0; i &lt; numCourses; i++) {\n            adjcent[i] = new ArrayList&lt;&gt;();\n        }\n        for (int[] pairs : prerequisites) {\n            adjcent[pairs[1]].add(pairs[0]);\n        }\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (!dfs(adjcent, i, visit)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean dfs(List&lt;Integer&gt;[] graph, int node, int[] visit) {\n        // Set 1: visited\n        // Set 0: unvisited\n        // Set -1: there is a conflict\n        if (visit[node] == 1) {\n            return true;\n        }\n\n        if (visit[node] == -1) {\n            return false;\n        }\n\n        visit[node] = -1;\n        for (int n : graph[node]) {\n            if (!dfs(graph, n, visit)) {\n                return false;\n            }\n        }\n        visit[node] = 1;\n        return true;\n    }\n}\n</code></pre>"},{"location":"200%2B/300.%20Longest%20Increasing%20Subsequence/","title":"300. Longest Increasing Subsequence","text":"<p>Source: https://leetcode.com/problems/longest-increasing-subsequence/description/</p>"},{"location":"200%2B/300.%20Longest%20Increasing%20Subsequence/#intuition","title":"Intuition","text":""},{"location":"200%2B/300.%20Longest%20Increasing%20Subsequence/#approach","title":"Approach","text":""},{"location":"200%2B/300.%20Longest%20Increasing%20Subsequence/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"200%2B/300.%20Longest%20Increasing%20Subsequence/#code","title":"Code","text":""},{"location":"400%2B/407.%20Trapping%20Rain%20Water%20II/","title":"407. Trapping Rain Water II","text":"<p>\ud83d\udd17 Source</p>"},{"location":"400%2B/407.%20Trapping%20Rain%20Water%20II/#approach","title":"Approach","text":"<p>Refer to this artical</p> <p>After calculating each position, in order to facilitate the search for the minimum value each time, we can add the calculated position to the minimum heap, and then continue to take the minimum value from the heap next time, and calculate its four directions of up, down, left, and right.</p> <p>For example, since 4 is the minimal value on the boundary, visit its neighbour(3), note that 3 &lt; 4, then for 3, it can fill 1 unit water, after visit 3 and fill the water, we need to update its height.</p> <p>Similarly, pick the minimum of the boundary, which is \"updated 3\", visit its neighbour 8 and 9, note that 9 &gt; 8 &gt; 4, then we can not fill water at 8 and 9. So we mark 8 and 9 as visit and continue....</p> <p></p>"},{"location":"400%2B/407.%20Trapping%20Rain%20Water%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(M*N*\\log(M*N))\\)</li> <li>Space complexity: \\(O(M*N)\\)</li> </ul>"},{"location":"400%2B/407.%20Trapping%20Rain%20Water%20II/#code","title":"Code","text":"<pre><code>class Solution {\n    public int trapRainWater(int[][] heightMap) {\n        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(\n            Comparator.comparingInt((int[] a) -&gt; a[2]));\n        int m = heightMap.length;\n        int n = heightMap[0].length;\n        boolean[][] visited = new boolean[m][n];\n\n        // Add the boundary value to priority queue\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                    pq.offer(new int[] {i, j, heightMap[i][j]});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        // Initialize the count variable and location array of up, down, left and right.\n        int total = 0;\n        int[][] loc = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n\n        // Traverse the priority queue\n        while (!pq.isEmpty()) {\n            int[] nums = pq.poll();\n            for (int[] l : loc) {\n                int x = nums[0] + l[0];\n                int y = nums[1] + l[1];\n                if (x &lt; 0 || y &lt; 0 || x &gt; m - 1 || y &gt; n - 1 || visited[x][y]) {\n                    continue;\n                }\n                visited[x][y] = true;\n                total += Math.max(0, nums[2] - heightMap[x][y]);\n                pq.add(new int[]{x, y, Math.max(nums[2], heightMap[x][y])});\n            }\n        }\n\n        return total;\n    }\n}\n</code></pre>"},{"location":"400%2B/407.%20Trapping%20Rain%20Water%20II/#similar-question","title":"Similar Question","text":"<ul> <li>Trapping Rain Water</li> </ul>"},{"location":"400%2B/417.%20Pacific%20Atlantic%20Water%20Flow/","title":"417. Pacific Atlantic Water Flow","text":"<p>\ud83d\udd17 Source</p>"},{"location":"400%2B/417.%20Pacific%20Atlantic%20Water%20Flow/#intuition","title":"Intuition","text":"<p>Giving you a 2-d metrix, you need to find all entries on the path to the \"edge\" of this metrix</p>"},{"location":"400%2B/417.%20Pacific%20Atlantic%20Water%20Flow/#approach","title":"Approach","text":"<p>Perform DFS on every entry on the edge of the metrix. And traverse the metrix to find all visited entries.</p> <ul> <li>Firstly, we creat a Pacific visited metrix and an Atlantic visit metrix.</li> <li>Secondly, we perform dfs on each edge and update our two visit metrices. <ul> <li>For entries where water is able to flow to the Pacific Ocean, perform DFS on each entry of the top and left side.</li> <li>For entries where water is able to flow to the Atlantic Ocean, perform DFS on each entry of the bottom and right side.</li> </ul> </li> <li>After we update our two visit metrices, we traverse them at same time to find entries whose rain water can flow to both the Pacific and Atlantic oceans.</li> </ul>"},{"location":"400%2B/417.%20Pacific%20Atlantic%20Water%20Flow/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(R\\times C)\\), where \\(R\\) is the number of rows and \\(C\\) is the number of columns</li> <li>Space complexity: \\(O(R\\times C)\\), as we creat two visit metrices.</li> </ul>"},{"location":"400%2B/417.%20Pacific%20Atlantic%20Water%20Flow/#code","title":"Code","text":"<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) {\n        int row = heights.length;\n        int col = heights[0].length;\n        boolean[][] pac = new boolean[row][col];\n        boolean[][] atl = new boolean[row][col];\n        for (int j = 0; j &lt; col; j++) {\n            dfs(0, j, row, col, heights[0][j], heights, pac);\n            dfs(row - 1, j, row, col, heights[row - 1][j], heights, atl);\n        }\n        for (int i = 0; i &lt; row; i++) {\n            dfs(i, 0, row, col, heights[i][0], heights, pac);\n            dfs(i, col - 1, row, col, heights[i][col - 1], heights, atl);\n        }\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        for (int i = 0; i &lt; row; i++) {\n            for (int j = 0; j &lt; col; j++) {\n                if (pac[i][j] &amp;&amp; atl[i][j]) {\n                    res.add(Arrays.asList(i,j));\n                }\n            }\n        }\n        return res;\n    }\n\n    private void dfs(int x, int y, int row, int col, int prev,\n                     int[][] height, boolean[][] visit) {\n        if (x &lt; 0 || x &gt;= row || y &lt; 0 || y &gt;= col || visit[x][y] || prev &gt; height[x][y]) {\n            return;\n        }\n        visit[x][y] = true;\n        dfs(x + 1, y, row, col, height[x][y], height, visit);\n        dfs(x, y + 1, row, col, height[x][y], height, visit);\n        dfs(x - 1, y, row, col, height[x][y], height, visit);\n        dfs(x, y - 1, row, col, height[x][y], height, visit);\n    }\n}\n</code></pre>"},{"location":"400%2B/424.%20Longest%20Repeating%20Character%20Replacement/","title":"424. Longest Repeating Character Replacement","text":"<p>Source: https://leetcode.com/problems/longest-repeating-character-replacement/description/</p>"},{"location":"400%2B/424.%20Longest%20Repeating%20Character%20Replacement/#intuition","title":"Intuition","text":""},{"location":"400%2B/424.%20Longest%20Repeating%20Character%20Replacement/#approach","title":"Approach","text":"<p>For this question, we use two pointer approach. By move the lower pointer and higher pointer, </p>"},{"location":"400%2B/424.%20Longest%20Repeating%20Character%20Replacement/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"400%2B/424.%20Longest%20Repeating%20Character%20Replacement/#code","title":"Code","text":"<pre><code>public int characterReplacement(String s, int k) {\n    int max = 0;\n    int res = 0;\n    int i = 0;\n    int j = 0;\n    int[] arr = new int[26];\n    while (i &lt; s.length()) {\n        arr[s.charAt(i) - 'A']++;\n        // record the max repeat number in the substring\n        // we only need to replace the rest letters in this \n        // substring\n        max = Math.max(max, arr[s.charAt(i) - 'A']);\n        // Number of replacement need\n        if (i - j + 1 - max &gt; k) {\n            // if the need &gt; restrict,\n            // move the lower pointer right\n            arr[s.charAt(j) - 'A']--;\n            j++;\n        }\n        // update the length of substring in the interating\n        // process\n        res = Math.max(i - j + 1, res);\n        i++;\n    }\n    return res;\n}\n</code></pre>"},{"location":"400%2B/435.%20Non-overlapping%20Intervals/","title":"435. Non-overlapping Intervals","text":"<p>\ud83d\udd17 Source</p>"},{"location":"400%2B/435.%20Non-overlapping%20Intervals/#intuition","title":"Intuition","text":"<p>Given an array of intervals (i.e.[starti, endi]), return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. - We need to sort the array anyway to reduce unnecessay operations!</p>"},{"location":"400%2B/435.%20Non-overlapping%20Intervals/#approach","title":"Approach","text":"<ul> <li>Step 1: Sort the array based on the RHS of each interval as the higher RHS, the more likely, it will contains more intervals</li> <li>Step 2: <ul> <li>Create a <code>prev</code> variable to store last valid position</li> <li>Create a <code>count</code> variable to store valid number of intervals</li> </ul> </li> <li>Step 3: Traverse the array, if <code>intervals[i][0] &gt;= intervals[prev][1]</code>, update the valid position and numbers, otherwise, move to the next one and perform checking.</li> <li>Step 4: Calculate the number of overlapping intervals to be removed and return.</li> </ul>"},{"location":"400%2B/435.%20Non-overlapping%20Intervals/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(N\\log N)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"400%2B/435.%20Non-overlapping%20Intervals/#code","title":"Code","text":"<pre><code>class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        // sort the array based on the RHS of each interval as the higher RHS,\n        // the more likely, it will contains more intervals\n        Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[1], b[1]));\n        // create a prev variable to store last valid position\n        int prev = 0;\n        // create a count variable to store valid number of intervals\n        int count = 1;\n        // traverse the array, if `intervals[i][0] &gt;= intervals[prev][1]`\n        // update the valid position and numbers\n        // otherwise, move to the next one and perform checking\n        for (int i = 0; i &lt; intervals.length; i++) {\n            if (intervals[i][0] &gt;= intervals[prev][1]) {\n                prev = i;\n                count++;\n            }\n        }\n        return intervals.length - count;\n    }\n}\n</code></pre>"},{"location":"Data%20Structure/array/","title":"Array","text":""},{"location":"Data%20Structure/array/#api","title":"API","text":"<p>Note</p> <p>Here, I have listed some commonly used generic methods. For the complete methods, please refer to Javadocs</p>"},{"location":"Data%20Structure/array/#class-arrays","title":"Class <code>Arrays</code>","text":"<p>Attention</p> <p>All method in class <code>Arrays</code> are <code>static</code> method!</p> <ul> <li><code>static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>: Returns a fixed-size list backed by the specified array.</li> <li><code>static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c)</code>: Searches a range of the specified array for the specified object using the binary search algorithm.</li> <li><code>static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code>: Searches the specified array for the specified object using the binary search algorithm.</li> <li><code>static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code>: Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length.</li> <li><code>static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to)</code>: Copies the specified range of the specified array into a new array.</li> <li><code>static void fill(Object[] a, int fromIndex, int toIndex, Object val)</code>: Assigns the specified Object reference to each element of the specified range of the specified array of Objects.</li> <li><code>static void fill(Object[] a, Object val)</code>: Assigns the specified Object reference to each element of the</li> <li><code>static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code>: Sorts the specified array of objects according to the order induced by the specified comparator.</li> </ul> Example <p>For a 2-d array, sort the array based on the RHS of each 'interval' <code>Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[1], b[1]));</code></p> <ul> <li><code>static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</code>: Sorts the specified range of the specified array of objects according to the order induced by the specified comparator.</li> <li><code>static String toString(Object[] a)</code>: Returns a string representation of the contents of the specified array.</li> </ul>"},{"location":"Data%20Structure/array/#class-array","title":"Class <code>Array</code>","text":"<ul> <li><code>static Object get(Object array, int index)</code>: Returns the value of the indexed component in the specified array object.</li> </ul>"},{"location":"Data%20Structure/array/#reference","title":"Reference","text":"<ul> <li>Javadocs/Arrays</li> <li>Javadocs/Array</li> </ul>"},{"location":"Data%20Structure/graph/","title":"Graph","text":""},{"location":"Data%20Structure/hash/","title":"Hashing","text":""},{"location":"Data%20Structure/hash/#api","title":"API","text":"<p>Note</p> <p>Here, I have listed some commonly used methods. For the complete methods, please refer to Javadocs</p>"},{"location":"Data%20Structure/hash/#class-hashsete","title":"Class <code>HashSet&lt;E&gt;</code>","text":""},{"location":"Data%20Structure/hash/#constructors","title":"Constructors","text":"<ul> <li><code>HashSet()</code></li> <li><code>HashSet(Collection&lt;? extends E&gt; c)</code>: Constructs a new set containing the elements in the specified collection. </li> <li><code>HashSet(int initialCapacity)</code>: Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and default load factor (0.75).</li> <li><code>HashSet(int initialCapacity, float loadFactor)</code>: Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and the specified load factor.</li> </ul>"},{"location":"Data%20Structure/hash/#method","title":"Method","text":"<ul> <li><code>boolean add(E e)</code>: Adds the specified element to this set if it is not already present.</li> <li><code>void clear()</code>: Removes all of the elements from this set.</li> <li><code>boolean contains(Object o)</code>: Returns true if this set contains the specified element.</li> <li><code>boolean isEmpty()</code>: Returns true if this set contains no elements.</li> <li><code>boolean remove(Object o)</code>: Removes the specified element from this set if it is present.</li> <li><code>int size()</code>: Returns the number of elements in this set (its cardinality).</li> <li><code>Object clone()</code>: Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.</li> </ul>"},{"location":"Data%20Structure/hash/#class-hashmapkv","title":"Class <code>HashMap&lt;K,V&gt;</code>","text":""},{"location":"Data%20Structure/hash/#constructors_1","title":"Constructors","text":"<ul> <li><code>HashMap()</code></li> <li><code>HashMap(Map&lt;? extends K,? extends V&gt; m)</code>: Constructs a new HashMap with the same mappings as the specified Map.</li> <li><code>HashMap(int initialCapacity)</code>: Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75).</li> <li><code>HashMap(int initialCapacity, float loadFactor)</code>: Constructs an empty HashMap with the specified initial capacity and load factor.</li> </ul>"},{"location":"Data%20Structure/hash/#method_1","title":"Method","text":"<ul> <li><code>void clear()</code>: Removes all of the mappings from this map.</li> <li><code>Object clone()</code>: Returns a shallow copy of this HashMap instance: the keys and values themselves are not cloned.</li> <li><code>boolean containsKey(Object key)</code>: Returns true if this map contains a mapping for the specified key.</li> <li><code>boolean containsValue(Object value)</code>: Returns true if this map maps one or more keys to the specified value.</li> <li><code>V get(Object key)</code>: Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.</li> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: Returns a Set view of the mappings contained in this map.</li> <li><code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>: Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.</li> <li><code>V getOrDefault(Object key, V defaultValue)</code>: Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.</li> <li><code>boolean isEmpty()</code>: Returns true if this map contains no key-value mappings.</li> <li><code>int size()</code>: Returns the number of key-value mappings in this map.</li> <li><code>Set&lt;K&gt; keySet()</code>: Returns a Set view of the keys contained in this map.</li> <li><code>Collection&lt;V&gt; values()</code>: Returns a Collection view of the values contained in this map.</li> <li><code>V put(K key, V value)</code> Associates the specified value with the specified key in this map.</li> <li><code>void putAll(Map&lt;? extends K,? extends V&gt; m)</code>: Copies all of the mappings from the specified map to this map.</li> <li><code>V putIfAbsent(K key, V value)</code>: If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.</li> <li><code>V remove(Object key)</code>: Removes the mapping for the specified key from this map if present.</li> <li><code>boolean remove(Object key, Object value)</code>: Removes the entry for the specified key only if it is currently mapped to the specified value.</li> <li><code>V replace(K key, V value)</code>: Replaces the entry for the specified key only if it is currently mapped to some value.</li> <li><code>boolean replace(K key, V oldValue, V newValue)</code>: Replaces the entry for the specified key only if currently mapped to the specified value.</li> </ul>"},{"location":"Data%20Structure/hash/#reference","title":"Reference","text":"<ul> <li>Javadocs/HashSet</li> <li>Javadocs/HashMap</li> </ul>"},{"location":"Data%20Structure/list/","title":"List","text":""},{"location":"Data%20Structure/list/#api","title":"API","text":"<p>Note</p> <p>Here, I have listed some commonly used methods. For the complete methods, please refer to Javadocs</p>"},{"location":"Data%20Structure/list/#class-arrayliste","title":"Class <code>ArrayList&lt;E&gt;</code>","text":"<p>Warning</p> <p>ArrayList is not array! (<code>ArrayList&lt;E&gt; &lt;: List&lt;E&gt;</code>)</p>"},{"location":"Data%20Structure/list/#constructors","title":"Constructors","text":"<ul> <li><code>ArrayList()</code>: Constructs an empty list with an initial capacity of ten.</li> <li><code>ArrayList(Collection&lt;? extends E&gt; c)</code>: Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.</li> <li><code>ArrayList(int initialCapacity)</code>: Constructs an empty list with the specified initial capacity.</li> </ul>"},{"location":"Data%20Structure/list/#method","title":"Method","text":"<ul> <li><code>void clear()</code>: Removes all of the elements from this list.</li> <li><code>boolean isEmpty()</code></li> <li><code>boolean contains(Object o)</code></li> <li><code>E get(int index)</code></li> <li><code>int size()</code></li> <li><code>void sort(Comparator&lt;? super E&gt; c)</code>: sort the list in \\(O(N\\log N)\\) time</li> <li><code>E set(int index, E element)</code>: Replaces the element at the specified position in this list with the specified element.</li> <li><code>boolean add(E e)</code>: Appends the specified element to the end of this list.</li> <li><code>void add(int index, E element)</code></li> <li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></li> <li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>: Inserts all of the elements in the specified collection into this list, starting at the specified position.</li> <li><code>void forEach(Consumer&lt;? super E&gt; action)</code>: Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception.</li> <li><code>int indexOf(Object o)</code>: Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.</li> <li><code>int lastIndexOf(Object o)</code>: Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.</li> <li><code>E remove(int index)</code>: Removes the element at the specified position in this list.</li> <li><code>boolean remove(Object o)</code>: Removes the first occurrence of the specified element from this list, if it is present.</li> <li><code>boolean removeAll(Collection&lt;?&gt; c)</code>: Removes from this list all of its elements that are contained in the specified collection.</li> <li><code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>: Removes all of the elements of this collection that satisfy the given predicate.</li> <li><code>protected void removeRange(int fromIndex, int toIndex)</code>: Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive.</li> <li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>: Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.</li> <li><code>Object[] toArray()</code>: Returns an array containing all of the elements in this list in proper sequence (from first to last element).</li> <li><code>&lt;T&gt; T[] toArray(T[] a)</code>: Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array.</li> <li><code>Object clone()</code>: Returns a shallow copy of this ArrayList instance.</li> <li><code>void ensureCapacity(int minCapacity)</code>: Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.</li> </ul>"},{"location":"Data%20Structure/list/#reference","title":"Reference","text":"<ul> <li>Javadocs/ArrayList</li> </ul>"},{"location":"Data%20Structure/tree/","title":"Tree","text":""},{"location":"Methodology/Binary%20Search/","title":"Binary Search and Edge Case","text":"<p>Quote</p> <p>Easy algorithms are hard to write correctly</p>"},{"location":"Methodology/Binary%20Search/#basic-template-of-binary-search","title":"Basic Template of Binary Search","text":"<pre><code>int binarySearch(int[] nums, int target) {\n    int left = 0; \n    int right = nums.length - 1; \n\n    while(left &lt;= right) {\n        int mid = left + (right - left) / 2;\n        if(nums[mid] == target)\n            return mid; \n        else if (nums[mid] &lt; target)\n            left = mid + 1; \n        else if (nums[mid] &gt; target)\n            right = mid - 1;\n    }\n    return -1;\n}\n</code></pre>"},{"location":"Methodology/Binary%20Search/#analysis","title":"Analysis","text":""},{"location":"Methodology/Binary%20Search/#loop-invariant","title":"Loop Invariant","text":"<p>Note that loop invariant is <code>left &lt;= right</code>, it means when loop terminate </p> <ul> <li>We find the <code>target</code> number</li> <li><code>left &gt; right</code>: this happens when <code>left = mid = right</code> and <code>nums[mid] != target</code>, thus the loop ends.</li> </ul> <p>Question</p> <p>Why we use <code>&lt;=</code> instead of <code>&lt;</code> in our loop invarinat</p>"},{"location":"Methodology/Binary%20Search/#search-for-left-boundary","title":"Search for Left boundary","text":"<p>Given an array of sorted numbers. Note that numbers could be duplicate, find the left most <code>target</code>.</p> <pre><code>public static int binaryLeftSearch(int[] nums, int target) {        \n    int low = 0\n    int high = nums.length - 1;\n    while (low &lt;= high) {\n        int mid = low + ((high - low) &gt;&gt; 1);\n        if (target &lt;= nums[mid]) {\n            index = mid;\n            high = mid - 1;\n        } else {\n            low = mid - 1;\n        }\n    }\n\n    if (index == -1) {\n        return -1;\n    }\n    return arr[index] == target ? index : -1;\n}\n</code></pre>"},{"location":"Methodology/Sliding%20Window/","title":"Sliding Window","text":""}]}